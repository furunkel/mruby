require 'stringio'

Register = Struct.new(:name) do
  def inspect
    "%#{name}"
  end
end

Literal = Struct.new(:value) do
  def inspect
    "$%#x" % value
  end
end

Instruction = Struct.new(:name, :operands, :bytes) do

  MAGIC_ARG_CONSTS = {
    /AB/i => 'a',
    /BC/i => 'b',
    /CD/i => 'c',
  }

  def arguments
    args = Hash.new{|k, v| k[v] = []}
    operands.map do |op|
      MAGIC_ARG_CONSTS.each do |r, a|
        v = case op
        when Literal
          op.value
        when X86::Memory
          op.offset
        else
          nil
        end

        if v && v.to_s(16) =~ /#{r}(\h\h)(\h\h)/i
          arg_bytes = [v].pack('l<').force_encoding('ASCII-8BIT').each_codepoint.to_a
          (bytes.size).downto(0) do |i|
            range = (i - arg_bytes.size)...i
            seq = bytes[range]
            if seq == arg_bytes
              mul_off, add_off = $1.to_i(16), $2.to_i(16)
              mul_off = 1 if mul_off.zero?
              args[a] << [mul_off, add_off, range]
            end
          end
        end
      end
    end
    args
  end

  def to_bytes
    bytes
  end

  def source
    operands[0]
  end

  def target
    operands[1]
  end

  def return?
    ['retq'].include? name
  end

  def call?
    !!(name =~ /call/)
  end

  def move?
    !!(name =~ /mov/)
  end

  def target_register?(reg_name)
    target.is_a?(Register) && target.name == reg_name
  end

  def source_register?(reg_name)
    source.is_a?(Register) && source.name == reg_name
  end

  def inspect
    "#{name}"
  end

  def bytesize
    bytes.size
  end

  def self.parse(str, bytes = [])
    name, operands_str = str.split(/\s+?/, 2)
    raise "invalid instruction #{str} (#{bytes})" if name.nil?
    operands_str ||= ''
    operands_str.strip!

    operands = []
    while !operands_str.empty?
      operands << case operands_str
      when /^\h+\s<.*?>/
      when /^\s*,\s*/
        nil
      when /^\$0x(\h+)/
        Literal.new $1.to_i(16)
      when /^\*?%(\w+)/
        Register.new $1.to_sym
      when /^\*?(?<offset>[+-]?0x\h+)?\((?:%(?<base>\w+))?(?:,%(?<index>\w+))?(?:,(?<scale>\d+))?\)/
        X86::Memory.new $~[:offset] && eval($~[:offset]),
                        $~[:base]   && Register.new($~[:base].to_sym),
                        $~[:index]  && Register.new($~[:index].to_sym),
                        $~[:scale]  && $~[:scale].to_i
      else
        operands << operands_str
        puts "invalid operand `#{operands_str}' (#{str})"
        break
      end
      operands_str = operands_str[$~.end(0)..-1]
    end
    operands.compact!

    new name, operands, bytes
  end

  def self.relative_jump(arch, *args)
    case arch
    when :x86, :x64
      X86
    end.const_get(:JumpInstruction).relative *args
  end
end

InstructionSet = Struct.new(:body) do
  def bytesize
    body.inject(0) do |acc, i|
      acc + i.bytesize
    end
  end
end

module X86

  module CC
    class SysV
      def self.argument_registers
        [:rdi, :rsi, :rdx, :rcx, :r8, :r9, *(0..7).map{|i| :"xmm#{i}"}].map{|n| Register.new n}
      end
    end
  end

  #0x48, 0x89, 0x7d, 0xf0,                   /*09: mov     %rdi, -0x10(%rbp)        */
  #0x48, 0x8b, 0x7d, 0xf0,                   /*42: mov     -0x10(%rbp), %rdi        */

  Memory = Struct.new(:offset, :base, :index, :scale) do
    def inspect
      o = offset && "%#+x".%(offset)
      b = base && base.inspect
      i = index && ',' + index.inspect
      s = scale && ',' + scale.to_s
      "#{o}(#{b}#{i}#{s})"
    end
  end

  class JumpInstruction < Instruction
    def self.relative(skip_n)
      case skip_n
      when rel8_range
        bytes = [rel8_opcode] + [skip_n].pack('c').force_encoding('ASCII-8BIT').each_codepoint.to_a
      when rel16_range
        bytes = [rel16_opcode] + [skip_n].pack('s<').force_encoding('ASCII-8BIT').each_codepoint.to_a
      else
        raise "jump size not supported"
      end

      new 'jmp', [], bytes
    end

    def self.register(register)
      bytes = [0xFF]
      bytes << case register.name
      when :rsi
        0xE6
      else
        raise "register jump with #{register.name} not supported"
      end

      new 'jmp', [register], bytes
    end

    module C
      def to_c(io = StringIO.new, mode = :relative)
        raise unless mode == :relative

        cond = -> (r) {"n >= #{r.min} && n < #{r.max}"}

        io.puts "int #{c_func_name}(uint8_t *b, int32_t n) {"
        io.puts "  if(#{cond[rel8_range]}) {"
        rel8_to_c io
        io.puts "    return 1;";
        io.puts "  }"
        io.puts "  if(#{cond[rel16_range]}) {"
        rel16_to_c io
        io.puts "    return 1;";
        io.puts "  }"
        io.puts "  return 0;"
        io.puts "}"

        io.string if StringIO === io
      end

      def c_func_name
        "jit_jump"
      end

      def rel8_to_c(io)
        io.puts "    *b++ = #{rel8_opcode};";
        io.puts "    *b++ = (int8_t) n;";
      end

      def rel16_to_c(io)
        opcode = rel16_opcode
        if opcode.is_a? Array
          opcode = opcode.map(&:chr).join.unpack('s<').first
          io.puts "    *((uint16_t *)(b)) = (uint16_t) #{opcode};";
          io.puts "    b += sizeof(uint16_t);";
        else
          io.puts "    *b++ = #{opcode};"
        end
        io.puts "    *((int16_t *)(b)) = (int16_t) n;";
        io.puts "    b += sizeof(int16_t);";
      end

      def rel8_range
        (-2**8/2...2**8/2)
      end

      def rel16_range
        (-2**16/2...2**16/2)
      end

      def rel8_opcode
        0xeb
      end

      def rel16_opcode
        0xe9
      end
    end

    extend C
    include C
  end

  class JumpIfInstruction < JumpInstruction
    module C
      extend JumpInstruction::C

      def c_func_name
        "jit_jump_if"
      end

      def rel8_opcode
        0x74
      end

      def rel16_opcode
        [0x0F,0x84]
      end
    end

    include C
    extend C
  end

  class JumpNotInstruction < JumpInstruction

    module C
      extend JumpInstruction::C

      def c_func_name
        "jit_jump_not"
      end

      def rel8_opcode
        0x75
      end

      def rel16_opcode
        [0x0F,0x85]
      end
    end

    include C
    extend C
  end


end

Operation = Struct.new(:name, :architecture, :instructions) do
  ARCH_MAP = {
    'i386:x86-64' => :x64,
    nil           => :unknown
  }

  alias_method :arch, :architecture

  def arguments
    body.inject([0, Hash.new{|h, v| h[v] = []}]) do |acc, op|
      off, hash = acc

      args = op.arguments.map {|k, v| [k, v.map{|(m, a, r)| [m, a, ((r.min + off)..(r.max + off))]}]}.to_h
      new_hash = hash.merge(args) do |key, av, hv|
        av | hv
      end

      [off + op.bytesize, new_hash]
    end[1]
  end

  def body
    instructions.body
  end

  def bytesize
    instructions.bytesize
  end

  def self.load(filename)
    parse `objdump -Sf #{filename}`
  end

  def self.parse(objdump)
    body = InstructionSet.new(objdump.each_line.inject([]) do |ary, line|
      if line =~ /:\t((?:[0-9a-f]{2}\s)+)\s+(.*)/
        bytes, asm = $1.strip, $2.strip
        bytes = bytes.split(/\s+/).map(&:strip).reject(&:empty?).map do |byte|
          byte.to_i(16)
        end

        asm.strip!

        if asm.empty?
          ary.last.bytes.concat bytes
        else
          ary << Instruction.parse(asm, bytes)
        end
      end

      ary
    end)

    objdump =~ /^architecture: (.*?),/
    arch = ARCH_MAP[$1]

    objdump =~ /^\d+ <(.*?)>:/
    func_name = $1

    klass = self
    klass_name = "_#{func_name}".gsub(/_([a-z])/){|m| $1.upcase}
    begin
      klass = Kernel::const_get klass_name
    rescue NameError
    end

    klass.new func_name, arch, body
  end

  def correct!
    remove_return!
    remove_dummy_call!
  end

  def remove_dummy_call!
    idx = body.rindex do |inst|
      inst.name == 'callq'
    end
    if idx
      body.delete_at idx
    end

    idx = body.rindex do |inst|
      inst.name == 'pop' && inst.source_register?(:rax)
    end
    if idx
      body.delete_at idx
    end

    idx = body.index do |inst|
      inst.name == 'push' && inst.source_register?(:rax)
    end
    if idx
      body.delete_at idx
    end
  end

  def remove_return!
    body.each_with_index.reverse_each.inject(0) do |acc, (inst, index)|
      if inst.return?
        if acc.zero?
          body.delete_at index
          inst = nil
        else
          inst = Instruction.relative_jump(arch, acc)
          body[index] = inst
        end
      end
      acc + (inst ? inst.bytesize : 0)
    end
  end
end

class OpEnter < Operation
  def correct!
    super

    idx = body.rindex do |inst|
      Literal === inst.operands[0] && inst.operands[0].value == 0xFAB
    end
    raise unless idx
    p idx
    if idx
      if body[idx + 1].call?
        mov, _ = body.slice! idx, 2

        # FIXME: assuming argument register 1 is not clobbered.
        # Since the dummy call is at the bottom of the function
        # that should normally not happen, though.
        body << X86::JumpInstruction.register(X86::CC::SysV.argument_registers[1])
      else
        raise
      end
    end
  end
end

def mruby_root
  __dir__.split(File::SEPARATOR)
         .slice_after('mruby').to_a[0]
         .join(File::SEPARATOR)
end

def ops_header_path(arch)
  File.join mruby_root, 'src', "ops_#{arch}.h"
end

def symtbl_header_path
  File.join mruby_root, 'src', "jit_symtbl.h"
end

def vm_c_path
 File.join mruby_root, 'src', 'vm.c'
end

def argument_usage
  data = File.read vm_c_path
  hash = {}
  data.scan(/(op_\w+)\s*\(([^\)]*)\)\s*\{([^\}]*)\}/m) do |h|
    op = $1
    args = $3.scan(/GETARG_(\w+)\s*\(/).flatten
    args_hash = {}
    args.each do |arg|
      p arg
      raise unless arg =~ /([ABCcb])/
      args_hash[$1.downcase.to_sym] = arg
    end
    hash[op] = args_hash
  end

  hash
end

#p argument_usage

$ops = [
  "op_nop", "op_move",
  "op_loadl", "op_loadi", "op_loadsym", "op_loadnil",
  "op_loadself", "op_loadt", "op_loadf",
  "op_getglobal", "op_setglobal", "op_getspecial", "op_setspecial",
  "op_getiv", "op_setiv", "op_getcv", "op_setcv",
  "op_getconst", "op_setconst", "op_getmcnst", "op_setmcnst",
  "op_getupvar", "op_setupvar",
  "op_jmp", "op_jmpif", "op_jmpnot",
  "op_onerr", "op_rescue", "op_poperr", "op_raise", "op_epush", "op_epop",
  "op_send", "op_sendb", "op_fsend",
  "op_call", "op_super", "op_argary", "op_enter",
  "op_karg", "op_kdict", "op_return", "op_tailcall", "op_blkpush",
  "op_add", "op_addi", "op_sub", "op_subi", "op_mul", "op_div",
  "op_eq", "op_lt", "op_le", "op_gt", "op_ge",
  "op_array", "op_arycat", "op_arypush", "op_aref", "op_aset", "op_apost",
  "op_string", "op_strcat", "op_hash",
  "op_lambda", "op_range", "op_oclass",
  "op_class", "op_module", "op_exec",
  "op_method", "op_sclass", "op_tclass",
  "op_debug", "op_stop", "op_err",
]

directory 'obj'
directory 'll'

obj_files = []

def gen_file(f)
  file f => ['vm.bc', 'll', 'gen'] do
    sym_tbl = eval(`./gen vm.bc ll`)

    File.open symtbl_header_path, 'w' do |f|
      f.puts "#define SYMTBL_SIZE #{sym_tbl.size}"
      f.puts "static void* symtbl[SYMTBL_SIZE];"
      f.puts "void init_symtbl() {"
      f.puts "  static int init = 0;"
      f.puts "  if(init == 0) {"
      f.puts "    init = 1;"
      sym_tbl.each_with_index do |s, i|
        f.puts "    symtbl[#{i}] = (void *) #{s};"
      end
      f.puts "  }"
      f.puts "}"
    end
  end
end

$ops.each do |op|
  ll_file = File.join('ll', "#{op}.ll")
  obj_file = File.join('obj', "#{op}.o")

  gen_file ll_file

  file obj_file => [ll_file, 'obj'] do |t|
    sh "llc -O3 #{ll_file} -filetype=obj -o #{t.name}"
  end

  obj_files << obj_file
end

gen_file symtbl_header_path


file 'vm.bc' => [vm_c_path] do |t|
  sh "clang -I#{File.join mruby_root, 'include'} -DMRB_JIT_GEN -fomit-frame-pointer -emit-llvm -o vm.bc -c #{vm_c_path}"
end

file ops_header_path(:x64) => [*obj_files, 'symtbl.h'] do |t|
  file = File.open t.name, 'w'
  arch = nil
  operations = obj_files.map do |obj|
    operation = Operation.load(obj)
    arch = operation.arch

    operation.correct!

    operation
  end

  operations.map do |operation|
    off = 0
    lines = operation.body.map do |inst|
      bin = inst.to_bytes
      op, opr = inst.name, inst.operands

      bin_str = bin.map{|byte| "0x%02x," % byte}.join(' ').ljust(42, ' ')
      asm_str = "#{op.ljust(8, ' ')}#{opr.map(&:inspect).join(", ")}"
      asm_str = "/*#{'%02x' % off}: #{asm_str.ljust(32, ' ')} */"

      off += inst.bytesize
      bin_str + asm_str
    end
    [operation, lines]
  end.each do |operation, lines|
    file.puts
    file.puts "/* args: #{operation.arguments.inspect} */"
    file.puts "static uint8_t #{operation.name}[] = {"
    lines.each do |l|
      file.puts "  " + l
    end
    file.puts "\n};"
    file.puts


    file.puts "static void #{operation.name}_set_args(uint8_t *op, int32_t a, int32_t b, int32_t c) {"
    operation.arguments.each do |k, vs|
      vs.each do |m, a, v|
        file.puts "  *((int32_t *)(op + #{v.begin})) = #{k} * #{m} + #{a};"
      end
    end
    file.puts "}"

    file.puts

    $argument_usage ||= argument_usage
    used_arguments = $argument_usage[operation.name]

    file.puts "static void #{operation.name}_set_args_from_code(uint8_t *op, mrb_code c) {"
    file.write "  #{operation.name}_set_args(op, "
    [:a, :b, :c].map do |arg|
      v = used_arguments[arg]
      if v
        "GETARG_#{v}(c)"
      else
        0
      end
    end.join(",").tap do |s|
      file.puts "#{s});"
    end
    file.puts "}"

    file.puts
  end

  file.puts "typedef void (*jit_args_func_t)(uint8_t *op, mrb_code c);"
  file.puts "static jit_args_func_t arg_funcs[#{operations.size}];"
  file.puts "static uint8_t* ops[#{operations.size}];"

  file.puts "static size_t op_sizes[] = {\n"
  operations.each do |op|
    file.puts "  sizeof(#{op.name}), /* #{op.name} */"
  end
  file.puts "\n};"

  file.puts

  file.puts "extern void init_symtbl();"
  file.puts "void init_ops() {"
  file.puts "  static int init = 0;"
  file.puts "  if(init == 0) {"
  file.puts "    init = 1;"
  file.puts "    init_symtbl();"
  operations.each_with_index do |op, index|
    file.puts "    ops[#{index}] = #{op.name};"
    file.puts "    arg_funcs[#{index}] = #{op.name}_set_args_from_code;"
  end
  file.puts "  }"
  file.puts "}"

  file.puts "int jit_return(uint8_t *b) {"
  file.puts "  *b++ = 0xc3;"
  file.puts "  return 1;"
  file.puts "}"

  X86::JumpInstruction.to_c file
  X86::JumpIfInstruction.to_c file
  X86::JumpNotInstruction.to_c file

  file.close
end

task :default => [ops_header_path(:x64), symtbl_header_path]

__END__
  0x53,                                     /*00: push    %rbx                     */
  0x48, 0x83, 0xec, 0x10,                   /*01: sub     $0x10, %rsp              */
  0x48, 0x89, 0xfb,                         /*05: mov     %rdi, %rbx               */
  0x48, 0x89, 0x5c, 0x24, 0x08,             /*08: mov     %rbx, +0x8(%rsp)         */
  0x48, 0x8b, 0x43, 0x18,                   /*0d: mov     +0x18(%rbx), %rax        */
  0x83, 0xb8, 0x08, 0xcd, 0xab, 0x00, 0x00, /*11: cmpl    $0, +0xabcd08(%rax)      */
  0x74, 0x0f,                               /*18: je                               */
  0x48, 0x8b, 0xbb, 0x90, 0x02, 0x00, 0x00, /*1a: mov     +0x290(%rbx), %rdi       */
  0x31, 0xc0,                               /*21: xor     %eax, %eax               */
  0xff, 0x93, 0x70, 0x01, 0x00, 0x00,       /*23: callq   +0x170(%rbx)             */
  0x48, 0x89, 0xdf,                         /*29: mov     %rbx, %rdi               */
  0x48, 0x83, 0xc4, 0x10,                   /*2c: add     $0x10, %rsp              */
  0x5b,                                     /*30: pop     %rbx                     */

